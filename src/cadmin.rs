use crate::ctanker::{free_buffer, tanker_future, CFuture};
use crate::Error;
use std::ffi::{c_void, CStr};

use self::bindings::*;
pub type CAdmin = *mut tanker_admin_t;
pub type CAppDescriptor = *mut tanker_app_descriptor_t;

#[allow(dead_code)] // Autogenerated code in cadmin.rs may be unused
mod bindings {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]
    #![allow(clippy::redundant_static_lifetimes)]
    include!(concat!(env!("NATIVE_BINDINGS_FOLDER"), "/cadmin.rs"));
}

pub async fn connect(admin_url: &CStr, id_token: &CStr) -> Result<CAdmin, Error> {
    let fut = unsafe {
        CFuture::new(
            tanker_admin_connect(admin_url.as_ptr(), id_token.as_ptr()) as *mut tanker_future
        )
    };
    fut.await
}

/// # Safety
/// `cadmin` must come from `connect` and must not be passed twice to `destroy`
pub async unsafe fn destroy(cadmin: CAdmin) -> Result<(), Error> {
    let fut = unsafe { CFuture::<c_void>::new(tanker_admin_destroy(cadmin) as *mut tanker_future) };
    fut.await.map(|_| ())
}

/// # Safety
/// `cadmin` must come from `connect` and must not have been passed to `destroy`
pub async unsafe fn create_app(cadmin: CAdmin, name: &CStr) -> Result<CAppDescriptor, Error> {
    let fut = unsafe {
        CFuture::new(tanker_admin_create_app(cadmin, name.as_ptr()) as *mut tanker_future)
    };
    fut.await
}

/// # Safety
/// `cadmin` must come from `connect` and must not have been passed to `destroy`
pub async unsafe fn delete_app(cadmin: CAdmin, id: &CStr) -> Result<(), Error> {
    let fut = unsafe {
        CFuture::<c_void>::new(tanker_admin_delete_app(cadmin, id.as_ptr()) as *mut tanker_future)
    };
    fut.await.map(|_| ())
}

/// # Safety
/// `cadmin` must come from `connect` and must not have been passed to `destroy`
pub async unsafe fn app_update(
    cadmin: CAdmin,
    id: &CStr,
    oidc_client_id: &CStr,
    oidc_provider: &CStr,
) -> Result<(), Error> {
    let fut = unsafe {
        CFuture::<c_void>::new(tanker_admin_app_update(
            cadmin,
            id.as_ptr(),
            oidc_client_id.as_ptr(),
            oidc_provider.as_ptr(),
        ) as *mut tanker_future)
    };
    fut.await.map(|_| ())
}

/// # Safety
/// `desriptor` must come from `create_app` and must not be passed twice to `descriptor_free`
pub unsafe fn descriptor_free(descriptor: CAppDescriptor) {
    unsafe { tanker_admin_app_descriptor_free(descriptor) };
}

pub async fn get_verification_code(
    url: &CStr,
    app_id: &CStr,
    auth_token: &CStr,
    email: &CStr,
) -> Result<String, Error> {
    let fut = unsafe {
        CFuture::new(tanker_get_verification_code(
            url.as_ptr(),
            app_id.as_ptr(),
            auth_token.as_ptr(),
            email.as_ptr(),
        ) as *mut tanker_future)
    };
    let str_ptr = fut.await?;
    let str = unsafe { CStr::from_ptr(str_ptr) }
        .to_str()
        .unwrap()
        .to_string();
    unsafe { free_buffer(str_ptr as _) };
    Ok(str)
}
