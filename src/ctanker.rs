mod cfuture;

pub use cfuture::*;
use std::marker::PhantomData;

mod cstream;

pub use cstream::*;

pub use self::bindings::tanker_future;
use self::bindings::*;

pub type CVerification = tanker_verification;
pub type CEmailVerification = tanker_email_verification;
pub type CVerificationMethod = tanker_verification_method;
pub type CDevice = tanker_device_list_elem;
pub type CTankerPtr = *mut tanker_t;
pub type CEncSessPtr = *mut tanker_encryption_session_t;
pub type LogHandlerCallback = Box<dyn Fn(LogRecord) + Send>;

use crate::{
    AttachResult, Device, EncryptionOptions, Error, ErrorCode, LogRecord, LogRecordLevel, Options,
    SharingOptions, Status, VerificationMethod, VerificationOptions,
};
use lazy_static::lazy_static;
use std::convert::TryFrom;
use std::ffi::{c_void, CStr, CString};
use std::os::raw::c_char;
use std::ptr::NonNull;
use std::sync::{Mutex, Once};

static RUST_SDK_VERSION: &str = env!("CARGO_PKG_VERSION");
static RUST_SDK_TYPE: &str = "client-rust";

static LOG_HANDLER_INITIALIZED: Once = Once::new();
lazy_static! {
    static ref LOG_HANDLER_CALLBACK: Mutex<Option<LogHandlerCallback>> = Mutex::new(None);
}

#[allow(dead_code)] // Autogenerated code in ctanker.rs may be unused
mod bindings {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]
    #![allow(clippy::redundant_static_lifetimes)]
    include!(concat!(env!("NATIVE_BINDINGS_FOLDER"), "/ctanker.rs"));
}

pub fn version_string() -> &'static str {
    let c_version = unsafe { CStr::from_ptr(tanker_version_string()) };
    c_version
        .to_str()
        .expect("tanker native version expected to be valid UTF-8")
}

pub fn init() {
    unsafe {
        // SAFETY: tanker_set_log_handler must be called once, and before any Tanker logs
        LOG_HANDLER_INITIALIZED.call_once(|| {
            tanker_set_log_handler(Some(log_handler_thunk));
        });
        tanker_init();
    }
}

unsafe extern "C" fn log_handler_thunk(clog: *const tanker_log_record) {
    let global_callback = LOG_HANDLER_CALLBACK.lock().unwrap();
    let callback = match global_callback.as_ref() {
        None => return,
        Some(cb) => cb,
    };

    // SAFETY: The native SDK always sends valid log records
    let record = unsafe {
        let category = CStr::from_ptr((*clog).category);
        let file = CStr::from_ptr((*clog).file);
        let message = CStr::from_ptr((*clog).message);
        let level = LogRecordLevel::try_from((*clog).level).unwrap();
        LogRecord {
            category: category.to_str().unwrap().to_string(),
            level,
            file: file.to_str().unwrap().to_string(),
            line: (*clog).line,
            message: message.to_str().unwrap().to_string(),
        }
    };
    callback(record);
}

pub unsafe fn set_log_handler(callback: LogHandlerCallback) {
    let mut global_callback = LOG_HANDLER_CALLBACK.lock().unwrap();
    *global_callback = Some(callback);
}

pub async fn create(options: Options) -> Result<CTankerPtr, Error> {
    let sdk_type = options
        .sdk_type
        .unwrap_or_else(|| CString::new(RUST_SDK_TYPE).unwrap());
    let sdk_version = CString::new(RUST_SDK_VERSION).unwrap();
    let coptions = tanker_options {
        version: 2,
        app_id: options.app_id.as_ptr(),
        url: options
            .url
            .as_ref()
            .map(|s| s.as_ptr())
            .unwrap_or(std::ptr::null()),
        writable_path: options.writable_path.as_ptr(),
        sdk_type: sdk_type.as_ptr(),
        sdk_version: sdk_version.as_ptr(),
    };

    let fut = unsafe { CFuture::new(tanker_create(&coptions)) };
    fut.await
}

pub async unsafe fn destroy(ctanker: CTankerPtr) {
    let fut = unsafe { CFuture::<c_void>::new(tanker_destroy(ctanker)) };
    let _ = fut.await; // Ignore errors, nothing useful we can do if destroy() fails
}

pub unsafe fn status(ctanker: CTankerPtr) -> Status {
    let status = unsafe { tanker_status(ctanker) };
    // SAFETY: The native lib never returns invalid status codes
    unsafe { Status::from_unchecked(status) }
}

pub async unsafe fn start(ctanker: CTankerPtr, identity: &str) -> Result<Status, Error> {
    let cidentity = CString::new(identity).map_err(|_| {
        Error::new(
            ErrorCode::InvalidArgument,
            "identity is not a valid CString".into(),
        )
    })?;
    let fut = unsafe { CFuture::<c_void>::new(tanker_start(ctanker, cidentity.as_ptr())) };
    fut.await.map(|status_voidptr| {
        // SAFETY: The native lib never returns invalid status codes
        unsafe { Status::from_unchecked(status_voidptr as u32) }
    })
}

pub async unsafe fn stop(ctanker: CTankerPtr) -> Result<(), Error> {
    let fut = unsafe { CFuture::<c_void>::new(tanker_stop(ctanker)) };
    fut.await.map(|_| ())
}

pub async unsafe fn generate_verification_key(ctanker: CTankerPtr) -> Result<String, Error> {
    let fut = unsafe { CFuture::new(tanker_generate_verification_key(ctanker)) };
    let str_ptr = fut.await?;
    let str = CStr::from_ptr(str_ptr).to_str().unwrap().to_owned();
    free_buffer(str_ptr as *const c_void);
    Ok(str)
}

pub async unsafe fn register_identity(
    ctanker: CTankerPtr,
    verification: *const CVerification,
    options: &VerificationOptions,
) -> Result<Option<String>, Error> {
    let c_options = tanker_verification_options {
        version: 1,
        with_session_token: options.with_session_token,
    };
    let fut = unsafe {
        CFuture::<c_void>::new(tanker_register_identity(ctanker, verification, &c_options))
    };
    let token_str_ptr = fut.await? as *mut i8;
    Ok(NonNull::new(token_str_ptr).map(|str_ptr| {
        let str = CStr::from_ptr(str_ptr.as_ptr())
            .to_str()
            .unwrap()
            .to_owned();
        free_buffer(str_ptr.as_ptr() as *mut c_void);
        str
    }))
}

pub async unsafe fn verify_identity(
    ctanker: CTankerPtr,
    verification: *const CVerification,
    options: &VerificationOptions,
) -> Result<Option<String>, Error> {
    let c_options = tanker_verification_options {
        version: 1,
        with_session_token: options.with_session_token,
    };
    let fut = unsafe {
        CFuture::<c_void>::new(tanker_verify_identity(ctanker, verification, &c_options))
    };
    let token_str_ptr = fut.await? as *mut i8;
    Ok(NonNull::new(token_str_ptr).map(|str_ptr| {
        let str = CStr::from_ptr(str_ptr.as_ptr())
            .to_str()
            .unwrap()
            .to_owned();
        free_buffer(str_ptr.as_ptr() as *mut c_void);
        str
    }))
}

pub async unsafe fn verify_provisional_identity(
    ctanker: CTankerPtr,
    verif: *const CVerification,
) -> Result<(), Error> {
    let fut = unsafe { CFuture::<c_void>::new(tanker_verify_provisional_identity(ctanker, verif)) };
    fut.await.map(|_| ())
}

pub async unsafe fn set_verification_method(
    ctanker: CTankerPtr,
    verification: *const CVerification,
    options: &VerificationOptions,
) -> Result<Option<String>, Error> {
    let c_options = tanker_verification_options {
        version: 1,
        with_session_token: options.with_session_token,
    };
    let fut = unsafe {
        CFuture::<c_void>::new(tanker_set_verification_method(
            ctanker,
            verification,
            &c_options,
        ))
    };
    let token_str_ptr = fut.await? as *mut i8;
    Ok(NonNull::new(token_str_ptr).map(|str_ptr| {
        let str = CStr::from_ptr(str_ptr.as_ptr())
            .to_str()
            .unwrap()
            .to_owned();
        free_buffer(str_ptr.as_ptr() as *mut c_void);
        str
    }))
}

pub async unsafe fn get_verification_methods(
    ctanker: CTankerPtr,
) -> Result<Vec<VerificationMethod>, Error> {
    let fut = unsafe { CFuture::new(tanker_get_verification_methods(ctanker)) };
    let list: &mut tanker_verification_method_list = unsafe { &mut *fut.await? };
    let methods = std::slice::from_raw_parts(list.methods, list.count as usize)
        .iter()
        .map(VerificationMethod::try_from)
        .collect();

    unsafe { free_verification_method_list(list) };
    methods
}

pub async unsafe fn device_id(ctanker: CTankerPtr) -> Result<String, Error> {
    let fut = unsafe { CFuture::new(tanker_device_id(ctanker)) };
    let str_ptr = fut.await?;
    let str = CStr::from_ptr(str_ptr).to_str().unwrap().to_owned();
    free_buffer(str_ptr as *const c_void);
    Ok(str)
}

pub async unsafe fn device_list(ctanker: CTankerPtr) -> Result<Vec<Device>, Error> {
    let fut = unsafe { CFuture::new(tanker_get_device_list(ctanker)) };
    let list: &mut tanker_device_list = unsafe { &mut *fut.await? };
    let methods = std::slice::from_raw_parts(list.devices, list.count as usize)
        .iter()
        .map(Device::from)
        .collect();

    unsafe { free_device_list(list) };
    Ok(methods)
}

struct EncryptionOptionsWrapper<'a> {
    _share_with_users: Vec<*const c_char>,
    _share_with_groups: Vec<*const c_char>,
    c_options: tanker_encrypt_options,
    phantom: PhantomData<&'a ()>,
}

impl EncryptionOptions {
    fn to_c_encryption_options<'a>(&'a self) -> EncryptionOptionsWrapper {
        let share_with_users = self
            .share_with_users
            .iter()
            .map(|u| u.as_ptr())
            .collect::<Vec<_>>();
        let share_with_groups = self
            .share_with_groups
            .iter()
            .map(|u| u.as_ptr())
            .collect::<Vec<_>>();

        let c_options = tanker_encrypt_options {
            version: 3,
            share_with_users: share_with_users.as_ptr(),
            nb_users: share_with_users.len() as u32,
            share_with_groups: share_with_groups.as_ptr(),
            nb_groups: share_with_groups.len() as u32,
            share_with_self: self.share_with_self,
        };

        EncryptionOptionsWrapper::<'a> {
            _share_with_users: share_with_users,
            _share_with_groups: share_with_groups,
            c_options,
            phantom: PhantomData,
        }
    }
}

pub async unsafe fn encrypt(
    ctanker: CTankerPtr,
    data: &[u8],
    options: &EncryptionOptions,
) -> Result<Vec<u8>, Error> {
    let encrypted_size = tanker_encrypted_size(data.len() as u64) as usize;
    let mut encrypted = Vec::with_capacity(encrypted_size);

    let options_wrapper = options.to_c_encryption_options();

    let fut = unsafe {
        CFuture::<c_void>::new(tanker_encrypt(
            ctanker,
            encrypted.as_mut_ptr(),
            data.as_ptr(),
            data.len() as u64,
            &options_wrapper.c_options,
        ))
    };
    fut.await?;

    // SAFETY: If tanker_encrypt succeeds, it guarantees to have written encrypted_size bytes
    unsafe { encrypted.set_len(encrypted_size) };

    Ok(encrypted)
}

pub async unsafe fn decrypt(ctanker: CTankerPtr, data: &[u8]) -> Result<Vec<u8>, Error> {
    let decrypted_size = unsafe {
        let fut = CFuture::<c_void>::new(tanker_decrypted_size(data.as_ptr(), data.len() as u64));
        fut.await? as usize
    };
    let mut decrypted = Vec::with_capacity(decrypted_size);

    let fut = unsafe {
        CFuture::<c_void>::new(tanker_decrypt(
            ctanker,
            decrypted.as_mut_ptr(),
            data.as_ptr(),
            data.len() as u64,
        ))
    };
    fut.await?;

    // SAFETY: If tanker_decrypt succeeds, it guarantees to have written decrypted_size bytes
    unsafe { decrypted.set_len(decrypted_size) };

    Ok(decrypted)
}

pub async unsafe fn share(
    ctanker: CTankerPtr,
    resource_ids: &[CString],
    options: &SharingOptions,
) -> Result<(), Error> {
    let resource_ids = resource_ids.iter().map(|u| u.as_ptr()).collect::<Vec<_>>();
    let share_with_users = options
        .share_with_users
        .iter()
        .map(|u| u.as_ptr())
        .collect::<Vec<_>>();
    let share_with_groups = options
        .share_with_groups
        .iter()
        .map(|u| u.as_ptr())
        .collect::<Vec<_>>();

    let coptions = tanker_sharing_options {
        version: 1,
        share_with_users: share_with_users.as_ptr(),
        nb_users: share_with_users.len() as u32,
        share_with_groups: share_with_groups.as_ptr(),
        nb_groups: share_with_groups.len() as u32,
    };

    let fut = unsafe {
        CFuture::<c_void>::new(tanker_share(
            ctanker,
            resource_ids.as_ptr(),
            resource_ids.len() as u64,
            &coptions,
        ))
    };
    fut.await.map(|_| ())
}

pub async unsafe fn attach_provisional_identity(
    ctanker: CTankerPtr,
    identity: &CStr,
) -> Result<AttachResult, Error> {
    let fut = unsafe {
        CFuture::new(tanker_attach_provisional_identity(
            ctanker,
            identity.as_ptr(),
        ))
    };
    let cresult: &mut tanker_attach_result = unsafe { &mut *fut.await? };
    let verification_method = if cresult.method.is_null() {
        None
    } else {
        // SAFETY: If method is non-null, it is a valid CVerificationMethod pointer
        let cmethod = unsafe { &mut *cresult.method };
        Some(VerificationMethod::try_from(cmethod)?)
    };
    let result = AttachResult {
        status: unsafe { Status::from_unchecked(cresult.status as u32) },
        verification_method,
    };

    unsafe { tanker_free_attach_result(cresult) };
    Ok(result)
}

pub async fn get_resource_id(data: &[u8]) -> Result<String, Error> {
    let fut = unsafe { CFuture::new(tanker_get_resource_id(data.as_ptr(), data.len() as u64)) };
    let str_ptr = fut.await?;
    // SAFETY: tanker_get_resource_id returns valid UTF-8 on success
    let str = unsafe { CStr::from_ptr(str_ptr).to_str().unwrap().to_owned() };
    unsafe { free_buffer(str_ptr as *const c_void) };
    Ok(str)
}

pub async unsafe fn create_group(
    ctanker: CTankerPtr,
    members: &[CString],
) -> Result<String, Error> {
    let member_ptrs = members.iter().map(|u| u.as_ptr()).collect::<Vec<_>>();

    let fut = unsafe {
        CFuture::new(tanker_create_group(
            ctanker,
            member_ptrs.as_ptr(),
            member_ptrs.len() as u64,
        ))
    };
    let str_ptr = fut.await?;
    let str = CStr::from_ptr(str_ptr).to_str().unwrap().to_owned();
    free_buffer(str_ptr as *const c_void);
    Ok(str)
}

pub async unsafe fn update_group_members(
    ctanker: CTankerPtr,
    group_id: &CStr,
    users_to_add: &[CString],
    users_to_remove: &[CString],
) -> Result<(), Error> {
    let users_to_add = users_to_add.iter().map(|u| u.as_ptr()).collect::<Vec<_>>();
    let users_to_remove = users_to_remove
        .iter()
        .map(|u| u.as_ptr())
        .collect::<Vec<_>>();

    let fut = unsafe {
        CFuture::<c_void>::new(tanker_update_group_members(
            ctanker,
            group_id.as_ptr(),
            users_to_add.as_ptr(),
            users_to_add.len() as u64,
            users_to_remove.as_ptr(),
            users_to_remove.len() as u64,
        ))
    };
    fut.await.map(|_| ())
}

pub async unsafe fn revoke_device(ctanker: CTankerPtr, device_id: &str) -> Result<(), Error> {
    let cdevice_id = CString::new(device_id).map_err(|_| {
        Error::new(
            ErrorCode::InvalidArgument,
            "device_id is not a valid CString".into(),
        )
    })?;

    let fut = unsafe { CFuture::<c_void>::new(tanker_revoke_device(ctanker, cdevice_id.as_ptr())) };
    fut.await.map(|_| ())
}

pub async unsafe fn encryption_session_open(
    ctanker: CTankerPtr,
    options: &EncryptionOptions,
) -> Result<CEncSessPtr, Error> {
    let options_wrapper = options.to_c_encryption_options();

    unsafe {
        CFuture::new(tanker_encryption_session_open(
            ctanker,
            &options_wrapper.c_options,
        ))
    }
    .await
}

pub async unsafe fn encryption_session_encrypt(
    csess: CEncSessPtr,
    data: &[u8],
) -> Result<Vec<u8>, Error> {
    let encrypted_size = tanker_encryption_session_encrypted_size(data.len() as u64) as usize;
    let mut encrypted = Vec::with_capacity(encrypted_size);

    unsafe {
        CFuture::<c_void>::new(tanker_encryption_session_encrypt(
            csess,
            encrypted.as_mut_ptr(),
            data.as_ptr(),
            data.len() as u64,
        ))
    }
    .await?;

    // SAFETY: If encrypt succeeds, it guarantees to have written encrypted_size bytes
    unsafe { encrypted.set_len(encrypted_size) };

    Ok(encrypted)
}

pub async fn encryption_session_get_resource_id(csess: CEncSessPtr) -> String {
    let fut = unsafe { CFuture::new(tanker_encryption_session_get_resource_id(csess)) };
    let str_ptr = fut.await.unwrap();
    // SAFETY: tanker_encryption_session_get_resource_id returns valid UTF-8
    let str = unsafe { CStr::from_ptr(str_ptr).to_str().unwrap().to_owned() };
    unsafe { free_buffer(str_ptr as *const c_void) };
    str
}

pub async unsafe fn encryption_session_close(csess: CEncSessPtr) -> Result<(), Error> {
    let fut = unsafe { CFuture::<c_void>::new(tanker_encryption_session_close(csess)) };
    fut.await.map(|_| ())
}

pub async fn prehash_password(pass: &str) -> Result<String, Error> {
    let cpass = CString::new(pass).map_err(|_| {
        Error::new(
            ErrorCode::InvalidArgument,
            "password is not a valid CString".into(),
        )
    })?;
    let fut = unsafe { CFuture::new(tanker_prehash_password(cpass.as_ptr())) };
    let str_ptr = fut.await?;
    unsafe {
        let str = CStr::from_ptr(str_ptr).to_str().unwrap().to_owned();
        free_buffer(str_ptr as *const c_void);
        Ok(str)
    }
}

pub unsafe fn free_buffer(buffer: *const c_void) {
    unsafe { tanker_free_buffer(buffer) }
}

unsafe fn free_verification_method_list(list: &mut tanker_verification_method_list) {
    unsafe { tanker_free_verification_method_list(list) }
}

unsafe fn free_device_list(list: &mut tanker_device_list) {
    unsafe { tanker_free_device_list(list) }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ctanker_version() {
        assert!(!version_string().is_empty());
    }
}
